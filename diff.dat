diff --git a/lib.cpp b/lib.cpp
index 7bcad491..d09bfe3b 100644
--- a/lib.cpp
+++ b/lib.cpp
@@ -46,18 +46,6 @@ inline double acos(const Double& x) {
 
 }
 
-
-//return the size of *this if shown in the wxWindow (e.g. a wxtextctr, a wxliscontrol, etc...). This is equivalent to the method String::get_size
-wxSize get_size(const String& s, wxWindow* p) {
-
-    wxClientDC dc(p);
-
-    return (dc.GetTextExtent(wxString(s.value)));
-
-}
-
-
-//put the angle x in the interval [-pi, pi), it does not alter *this and returns the result. This is equivalent to Angle::normalize_pm_pi_ret
 inline Angle normalize_pm_pi_ret(const Angle& x){
         
     Angle result;
@@ -1962,15 +1950,40 @@ MyRectangle::MyRectangle(void) {
 
 }
 
-
 //constructor which constructs p_NW and p_SE from p_NW_in and p_SE_in. For this to work, p_NW_in must lie at the NW of p_SE_in
 MyRectangle::MyRectangle(Position p_NW_in, Position p_SE_in, [[maybe_unused]] String prefix) {
 
+    //    Angle phi_N, phi_S, lambda_W, lambda_E;
+    //
+    //    //select the largest longitude among the lonngitudes of a and b, and set the longitude of p_NW to be such longitude. Do the same for the latitude
+    //
+    //    phi_N = max((a.phi).normalize_pm_pi_ret(), (b.phi).normalize_pm_pi_ret());
+    //    phi_N.normalize();
+    //
+    //    phi_S = min((a.phi).normalize_pm_pi_ret(), (b.phi).normalize_pm_pi_ret());
+    //    phi_S.normalize();
+    //
+    //    lambda_W = max((a.lambda).normalize_pm_pi_ret(), (b.lambda).normalize_pm_pi_ret());
+    //    lambda_W.normalize();
+    //
+    //    lambda_E = min((a.lambda).normalize_pm_pi_ret(), (b.lambda).normalize_pm_pi_ret());
+    //    lambda_E.normalize();
+
+
+    //    p_NW = Position(lambda_W, phi_N);
+    //    p_SE = Position(lambda_E, phi_S);
+
+
     p_NW = p_NW_in;
     p_SE = p_SE_in;
 
-}
+    //    if(!((((p_NW_in.lambda).normalize_pm_pi_ret()) > ((p_SE_in.lambda).normalize_pm_pi_ret())) && (((p_NW_in.phi).normalize_pm_pi_ret()) > ((p_SE_in.phi).normalize_pm_pi_ret())))){
+    //
+    //        cout << prefix.value << RED << "p_NW and p_SE are not ordered!\n" << RESET;
+    //
+    //    }
 
+}
 
 //returns true/false if p is containted in *this
 bool MyRectangle::Contains(Position p) {
@@ -1988,6 +2001,7 @@ bool MyRectangle::Contains(Position p) {
 
         check_lambda = (((p.lambda) < (p_NW.lambda)) || ((p.lambda) > (p_SE.lambda)));
 
+
     }
 
     return(check_lambda &&
@@ -1996,7 +2010,6 @@ bool MyRectangle::Contains(Position p) {
 
 }
 
-
 //construct a brand new Route object and thus sets its related sight to -1, because this Route is not related to any sight yet. length_format_t_v is set to false: as the Route is created, lengths are written in l rather than in t and v
 Route::Route(void) {
 
@@ -2019,8 +2032,7 @@ Route::Route(String type_in, Position reference_position_in, Angle Z_in, Length
 
 }
 
-
-//construct a brand new Route object of type 'c' and thus sets its related sight to -1, because this Route is not related to any sight yet.  length_format_t_v is set to false: as the Route is created, lengths are written in l rather than in t and v
+//constructs a brand new Route object of type 'c' and thus sets its related sight to -1, because this Route is not related to any sight yet.  length_format_t_v is set to false: as the Route is created, lengths are written in l rather than in t and v
 Route::Route(String type_in, Position reference_position_in, Angle omega_in) {
 
     type = type_in;
@@ -2035,7 +2047,7 @@ Route::Route(String type_in, Position reference_position_in, Angle omega_in) {
 
 }
 
-//add the Route this to the wxListCtrl listcontrol
+//I add the Route this to the wxListCtrl listcontrol
 void Route::add_to_wxListCtrl(long position_in_listcontrol, wxListCtrl* listcontrol) {
 
     unsigned int i;
@@ -8440,18 +8452,12 @@ inline void DrawPanel::PaintEvent([[maybe_unused]] wxPaintEvent& event) {
 
 
 //render the mouse position with colors foreground_color and background_color
-inline void DrawPanel::RenderMousePositionLabel(
-                                                wxDC& dc,
-                                                const String& label_position,
-                                                const wxPoint& position_label_position,
-                                                wxColor foreground_color,
-                                                wxColor background_color
-                                                ) {
+inline void DrawPanel::RenderMousePositionLabel(wxDC& dc, String label_position, wxPoint position_label_position, wxColor foreground_color, wxColor background_color) {
 
     //wipe out position_label_position by writing on top of it a rectangle filled with color backgound_color
     dc.SetPen(background_color);
     dc.SetBrush(wxBrush(background_color, wxBRUSHSTYLE_SOLID));
-    dc.DrawRectangle(position_label_position, get_size(label_position, this));
+    dc.DrawRectangle(position_label_position, label_position.get_size(&dc));
 
     dc.SetTextForeground(foreground_color);
     dc.SetTextBackground(background_color);
@@ -8526,12 +8532,7 @@ inline void DrawPanel::RenderBackground(
 
 
 //same as  DrawPanel::RenderSelectionRectangle(wxDC& dc, Position geo_position, wxColour foreground_color, wxColour background_color), but it takes a  position (reckoned with respect to the ordigin of *this) as input rather than a  geographic Position
-inline void DrawPanel::RenderSelectionRectangle(wxDC& dc,
-                                                const wxPoint& position,
-                                                const wxPoint& position_end_label,
-                                                const String& end_label,
-                                                wxColour foreground_color,
-                                                wxColour background_color) {
+inline void DrawPanel::RenderSelectionRectangle(wxDC& dc, wxPoint position, wxPoint position_end_label, String end_label, wxColour foreground_color, wxColour background_color) {
 
     Position p;
 
@@ -8542,12 +8543,7 @@ inline void DrawPanel::RenderSelectionRectangle(wxDC& dc,
 
 
 //render a selection rectangle with end Position geo_position (geographic position), foreground color foreground_color and backgrund color background_color, and label at its endpoint end_label located at position_end_label
-inline void DrawPanel::RenderSelectionRectangle(wxDC& dc, 
-                                                const Position& geo_position,
-                                                const wxPoint& position_end_label,
-                                                const String& end_label,
-                                                wxColour foreground_color,
-                                                wxColour background_color) {
+inline void DrawPanel::RenderSelectionRectangle(wxDC& dc, Position geo_position, wxPoint position_end_label, String end_label, wxColour foreground_color, wxColour background_color) {
 
 
     dc.SetPen(foreground_color);
@@ -8561,16 +8557,16 @@ inline void DrawPanel::RenderSelectionRectangle(wxDC& dc,
     (Route(
         String("o"),
         (parent->parent->geo_position_start),
-        Angle(M_PI * (1.0 - GSL_SIGN((normalize_pm_pi_ret(geo_position.phi).value) - ((((parent->parent->geo_position_start).phi).normalize_pm_pi_ret()).value))) / 2.0),
-        Length(Re * fabs((normalize_pm_pi_ret(geo_position.phi).value) - ((((parent->parent->geo_position_start).phi).normalize_pm_pi_ret()).value)))
+        Angle(M_PI * (1.0 - GSL_SIGN((((geo_position.phi).normalize_pm_pi_ret()).value) - ((((parent->parent->geo_position_start).phi).normalize_pm_pi_ret()).value))) / 2.0),
+        Length(Re * fabs((((geo_position.phi).normalize_pm_pi_ret()).value) - ((((parent->parent->geo_position_start).phi).normalize_pm_pi_ret()).value)))
     )).Draw((((parent->parent->data)->n_points_routes).value), &dc, this, String(""));
 
     //left vertical edge of rectangle
     (Route(
         String("o"),
         geo_position,
-        Angle(M_PI * (1.0 + GSL_SIGN((normalize_pm_pi_ret(geo_position.phi).value) - ((((parent->parent->geo_position_start).phi).normalize_pm_pi_ret()).value))) / 2.0),
-        Length(Re * fabs((normalize_pm_pi_ret(geo_position.phi).value) - ((((parent->parent->geo_position_start).phi).normalize_pm_pi_ret()).value)))
+        Angle(M_PI * (1.0 + GSL_SIGN((((geo_position.phi).normalize_pm_pi_ret()).value) - ((((parent->parent->geo_position_start).phi).normalize_pm_pi_ret()).value))) / 2.0),
+        Length(Re * fabs((((geo_position.phi).normalize_pm_pi_ret()).value) - ((((parent->parent->geo_position_start).phi).normalize_pm_pi_ret()).value)))
     )).Draw((((parent->parent->data)->n_points_routes).value), &dc, this, String(""));
 
     //bottom horizontal edge of rectangle
@@ -8578,8 +8574,8 @@ inline void DrawPanel::RenderSelectionRectangle(wxDC& dc,
         String("l"),
         (parent->parent->geo_position_start),
         //change this by introducing if
-        Angle(M_PI_2 + M_PI * (1.0 + GSL_SIGN((normalize_pm_pi_ret(geo_position.lambda).value) - ((((parent->parent->geo_position_start).lambda).normalize_pm_pi_ret()).value))) / 2.0),
-        Length(Re * cos((parent->parent->geo_position_start).phi) * fabs((normalize_pm_pi_ret(geo_position.lambda).value) - ((((parent->parent->geo_position_start).lambda).normalize_pm_pi_ret()).value)))
+        Angle(M_PI_2 + M_PI * (1.0 + GSL_SIGN((((geo_position.lambda).normalize_pm_pi_ret()).value) - ((((parent->parent->geo_position_start).lambda).normalize_pm_pi_ret()).value))) / 2.0),
+        Length(Re * cos((parent->parent->geo_position_start).phi) * fabs((((geo_position.lambda).normalize_pm_pi_ret()).value) - ((((parent->parent->geo_position_start).lambda).normalize_pm_pi_ret()).value)))
     )).DrawOld((((parent->parent->data)->n_points_routes).value), &dc, this, String(""));
 
     //top horizontal edge of rectangle
@@ -8587,8 +8583,8 @@ inline void DrawPanel::RenderSelectionRectangle(wxDC& dc,
         String("l"),
         geo_position,
         //change this by introducing if
-        Angle(M_PI_2 + M_PI * (1.0 - GSL_SIGN((normalize_pm_pi_ret(geo_position.lambda).value) - ((((parent->parent->geo_position_start).lambda).normalize_pm_pi_ret()).value))) / 2.0),
-        Length(Re * cos(geo_position.phi) * fabs((normalize_pm_pi_ret(geo_position.lambda).value) - ((((parent->parent->geo_position_start).lambda).normalize_pm_pi_ret()).value)))
+        Angle(M_PI_2 + M_PI * (1.0 - GSL_SIGN((((geo_position.lambda).normalize_pm_pi_ret()).value) - ((((parent->parent->geo_position_start).lambda).normalize_pm_pi_ret()).value))) / 2.0),
+        Length(Re * cos(geo_position.phi) * fabs((((geo_position.lambda).normalize_pm_pi_ret()).value) - ((((parent->parent->geo_position_start).lambda).normalize_pm_pi_ret()).value)))
     )).DrawOld((((parent->parent->data)->n_points_routes).value), &dc, this, String(""));
 
 
@@ -8596,7 +8592,7 @@ inline void DrawPanel::RenderSelectionRectangle(wxDC& dc,
     //wipe out the space occupied by the label
     dc.SetPen(wxPen(background_color));
     dc.SetBrush(wxBrush(background_color, wxBRUSHSTYLE_SOLID));
-    dc.DrawRectangle(position_end_label, get_size(end_label, this));
+    dc.DrawRectangle(position_end_label, end_label.get_size(&dc));
 
     //render the rectangle
     dc.SetTextForeground(foreground_color);
@@ -8660,13 +8656,7 @@ inline void DrawPanel::RenderAll(wxDC& dc) {
 }
 
 //render the Routes whose point coordinates with respect to the origin of DrawPanel are stored in points_curves, and whose reference-position coordinates with respect to the origin of DrawPanel are stored in reference_positions. the Route #highlighted_route is rendered with larger thickness. If foreground_color != wxNUllColour, the Routes are rendered with the colors in color_list, otherwise they are rendered with foreground_color
-inline void DrawPanel::RenderRoutes(
-                                    wxDC& dc,
-                                    const vector< vector< vector<wxPoint> > >& points_curves,
-                                    const vector<wxPoint>& reference_positions,
-                                    int highlighted_route,
-                                    wxColor foreground_color
-                                    ) {
+inline void DrawPanel::RenderRoutes(wxDC& dc, vector< vector< vector<wxPoint> > > points_curves, vector<wxPoint> reference_positions, int highlighted_route, wxColor foreground_color) {
 
     int i, j, color_id;
     double thickness, radius;
@@ -8939,10 +8929,7 @@ inline void DrawPanel::MyRefresh(void) {
 
 
 //render the Positions:  if foreground_color == wxNullColour, this method uses as foreground color the colors in color_list, otherwise it uses foreground_color
-inline void DrawPanel::RenderPositions(wxDC& dc, 
-                                       const vector<wxPoint>& points,
-                                       int highlighted_position,
-                                       wxColor foreground_color) {
+inline void DrawPanel::RenderPositions(wxDC& dc, vector<wxPoint> points, int highlighted_position, wxColor foreground_color) {
 
     int i, color_id;
     double thickness, radius;
@@ -8980,17 +8967,13 @@ inline void DrawPanel::RenderPositions(wxDC& dc,
 
 
 //render the coordinates of an object (Route or Position) which is being dragged by rendering the label label_dragged_object at position position_label_dragged_object (reckoned with respect to the origin of *this)
-inline void DrawPanel::RenderDraggedObjectLabel(wxDC& dc, 
-                                                const wxPoint& position_label_dragged_object,
-                                                const String& label_dragged_object,
-                                                wxColor foreground_color,
-                                                wxColor background_color) {
+inline void DrawPanel::RenderDraggedObjectLabel(wxDC& dc, wxPoint position_label_dragged_object, String  label_dragged_object, wxColor foreground_color, wxColor background_color) {
 
 
     //wipe out the space occupied by the label
     dc.SetPen(wxPen(background_color));
     dc.SetBrush(wxBrush(background_color, wxBRUSHSTYLE_SOLID));
-    dc.DrawRectangle(position_label_dragged_object, get_size(label_dragged_object, this));
+    dc.DrawRectangle(position_label_dragged_object, label_dragged_object.get_size(&dc));
 
 
     //render label_dragged_object
@@ -9028,15 +9011,17 @@ void DrawPanel::FitAll() {
 }
 
 //remember that any Draw command in this function takes as coordinates the coordinates relative to the position of the DrawPanel object!
-inline void DrawPanel::Render_Mercator(wxDC* dc,
-                                       const vector< vector< vector<wxPoint> > >& grid,
-                                       const vector< vector< vector<wxPoint> > >& ticks,
-                                       const vector<wxString>& parallels_and_meridians_labels,
-                                       const vector<wxPoint>& positions_parallels_and_meridians_labels,
-                                       const vector<wxPoint>& points_coastline,
-                                       wxColor foreground_color,
-                                       wxColor background_color,
-                                       double thickness) {
+inline void DrawPanel::Render_Mercator(
+    wxDC* dc,
+    vector< vector< vector<wxPoint> > > grid,
+    vector< vector< vector<wxPoint> > > ticks,
+    vector<wxString> parallels_and_meridians_labels,
+    vector<wxPoint> positions_parallels_and_meridians_labels,
+    vector<wxPoint> points_coastline,
+    wxColor foreground_color,
+    wxColor background_color,
+    double thickness
+) {
 
     Angle lambda, phi;
     Route route;
@@ -9104,7 +9089,7 @@ inline void DrawPanel::Render_Mercator(wxDC* dc,
 }
 
 
-//This function writes into *output the text label for a parallel or a meridian. The latitude/longitude in the text label is q.phi/q.lambda, min and max are the minimal and maximal latitudes/longitudes that are covered in the drawing process of the label by DrawPanel::SetLabel, they must be sorted in such a way that (max.normalize_pm_pi_ret()).value > (min.normalize_pm_pi_ret()).value. mode = "NS" or "EW" specifices whether the label to be plotted is a latitude or a longitude label, respectively. The output is written int *output
+//This function writes into *output the text label for a parallel or a meridia. The latitude/longitude in the text label is q.phi/q.lambda, min and max are the minimal and maximal latitudes/longitudes that are covered in the drawing process of the label by DrawPanel::SetLabel, they must be sorted in such a way that (max.normalize_pm_pi_ret()).value > (min.normalize_pm_pi_ret()).value. mode = "NS" or "EW" specifices whether the label to be plotted is a latitude or a longitude label, respectively. The output is written int *output
 void DrawPanel::WriteLabel(const Position& q, Angle min, Angle max, Int precision, String mode, wxString* output) {
 
     double delta;
@@ -9224,17 +9209,17 @@ void DrawPanel::DrawLabel(const Position& q, Angle min, Angle max, Int precision
 
 //This function renders the chart in the 3D case. remember that any Draw command in this function takes as coordinates the coordinates relative to the position of the DrawPanel object!
 inline void DrawPanel::Render_3D(
-                                 wxDC* dc,
-                                 const vector< vector< vector<wxPoint> > >& grid,
-                                 const vector< vector< vector<wxPoint> > >& ticks,
-                                 const vector<wxString>& parallels_and_meridians_labels,
-                                 const vector<wxPoint>& positions_parallels_and_meridians_labels,
-                                 const vector<wxPoint>& points_coastline,
-                                 wxColor foreground_color,
-                                 wxColor background_color,
-                                 double thickness
-                                 ) {
-    
+    wxDC* dc,
+    vector< vector< vector<wxPoint> > > grid,
+    vector< vector< vector<wxPoint> > > ticks,
+    vector<wxString> parallels_and_meridians_labels,
+    vector<wxPoint> positions_parallels_and_meridians_labels,
+    vector<wxPoint> points_coastline,
+    wxColor foreground_color,
+    wxColor background_color,
+    double thickness
+) {
+
     int i, j;
     Double d_temp;
     Angle lambda;
