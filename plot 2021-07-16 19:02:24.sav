reset 

#notes:
#to kill all gnuplot processes type: pkill -9 gnuplot
#- using webgeocals improves agreement between circle of equal altitude and true position by ~ 100 m
#do not use stellarium to compute hour angle and declination: they are calculated with the reference frame sitting on the surface of the earth at the observer's location! 
#here 0 <= lambda < 360.0, and it grows in the W direction
#notes
K = 360.0/(2.0*pi);
k = 1.0/K;
N = 12.0;
#coastlines are plotted every S lines
S = 1e3;
M = 1e2;
epsilon=1e-12
myint(x) = x>0.0 ? int(x) : int(x)-1.0
clint(x) = abs(x-myint(x))<abs(x-(myint(x)+1.)) ? myint(x) : myint(x)+1.

#Mercator for the sphere
#MINUS SIGN ADDED BY HAND TO FLIP THE MAP
xe(lambda) =  (-1.0) * ( ((0.0 <= lambda) & (lambda < 180.0)) ? lambda: lambda - 360.0 )*k
ye(phi) = (log(1./cos(phi*k) + tan(phi*k)))
lambda_inv(xe) = ( ((xe <= 0.0) & (xe > -pi)) ? -xe*K: -xe*K + 360.0 )
#given xe, this returns the corresponding lambda in non-standard format, i.e., lying in the interval [-pi, pi)
lambda_inv_pm(xe) = -xe*K 
phi_inv(ye) = K*atan(sinh(ye))	

myf(x,y)=sprintf("%g\260 %g' %s , %g\260 %g' %s", myint(abs(phi_inv(y))), (abs(phi_inv(y)) - myint(abs(phi_inv(y))))*60.0, (phi_inv(y) > 0.0 ? 'N': 'S'), myint(abs(lambda_inv_pm(x))), (abs(lambda_inv_pm(x)) - myint(abs(lambda_inv_pm(x))))*60.0, ((lambda_inv_pm(x) > 0.0) ? 'W': 'E'))
set mouse mouseformat function myf(x, y)
set mouse mouseformat 8


#clear
set parametric
set multiplot

set size ratio -1
set ticscale 3,1
set samples S
#increments in degrees
increment_phi = 20.0;
increment_lambda = 60.0;
list(start,end,increment)=system(sprintf("seq %g %g %g", start, increment, end))


#set tics scale 0


Phi(t, d, GHA, cH) =pi/2.-acos(cos(cH) * sin(d)-cos(d) * cos(t) * sin(cH))
Lambda(t, d, GHA, cH) = ( lambda = -(atan((-sin(GHA) * (cos(d)* cos(cH)+cos(t) * sin(d) * sin(cH))+cos(GHA) * sin(cH) * sin(t))/(cos(d) * cos(GHA) * cos(cH)+sin(cH)*  (cos(GHA) * cos(t) * sin(d)+sin(GHA)* sin(t)))) + (cos(d)* cos(GHA)* cos(cH) +  sin(cH) * (cos(GHA)* cos(t) * sin(d) + sin(GHA)  *sin(t)) >0.0 ? 0.0 : pi)) , lambda - 2.0*pi*floor(lambda/(2.0*pi)))





#angles are in degrees
lambda_min = 180.0 - epsilon
lambda_max = 180.0 + epsilon
phi_min = -80.0
phi_max = 80.0

set xrange [xe(lambda_min):xe(lambda_max)]
set yrange [ye(phi_min):ye(phi_max)]

dx = ye((phi_min+phi_max)/2.0+1./60.) -  ye((phi_min+phi_max)/2.0)

set style arrow 1 nohead ls 1 lw 1 linecolor rgb 'black'
set style arrow 2 nohead ls 1 lw 1 linecolor rgb 'gray'


label_rose(n) = sprintf("\\scalebox{0.3}{$\\color{mygray}{%d}$}",n)
label_deg(x) = sprintf("%.f\260", x)


#GPS position
lambda0 = 360.0 -(2.0 + 24./60. + 26.07/(60.**2.))
phi0 = 48.0 + 51./60. + 19.63/(60.**2.)
set object circle at  xe(lambda0),ye(phi0) radius char 1  fillcolor rgb 'red' fillstyle solid noborder

#coastlines
plot   '/Users/mcastellana/Documents/navigational_astronomy_large_files/coastlines_2/map_conv.csv' u (xe(-$1+360.0)):(ye($2)) every M w d linecolor rgb "gray" noti

replot [0.:2.*pi] xe(K*Lambda(t, 5.9982615980375602049434746732004, 5.4840820990703056381221358606126, 1.2353722130966189318712622480234)), ye(K*Phi(t, 5.9982615980375602049434746732004, 5.4840820990703056381221358606126, 1.2353722130966189318712622480234)) smo csp ti "sun 2024-02-04 09:11:09 TAI"

replot "+" u (xe(K*(0.57683131778412588541726790936082))):(ye(K*(0.96138552964020984603621400310658))) w p  lw 2 ti "c cid d "


#unset parametric
unset multiplot

x_max_old = xe(lambda_max);

while(1){

	if(GPVAL_DATA_X_MAX!=x_max_old){


	unset arrow;
	

	#print "Recalculating tics ... ";

	lambda_min = lambda_inv(GPVAL_DATA_X_MIN);
	lambda_max = lambda_inv(GPVAL_DATA_X_MAX);
	
	phi_min = phi_inv(GPVAL_DATA_Y_MIN);
	phi_max = phi_inv(GPVAL_DATA_Y_MAX);

	set xrange [xe(lambda_min):xe(lambda_max)]
	set yrange [ye(phi_min):ye(phi_max)]

	phi_span = phi_max - phi_min;
	lambda_span = -(-(GPVAL_DATA_X_MAX - GPVAL_DATA_X_MIN)*K);
	
	#print "lambda in [" , lambda_min , " , " , lambda_max , "]";
	#print "phi in [" , phi_min , " , " , phi_max , "]";

	#print "Determining dlambda ...";
	
	dlambda=1.0;
	while(N*dlambda<lambda_span){
#		#print dlambda;
		if(dlambda == 1.0){dlambda = dlambda + 4.0;}
		else{dlambda = dlambda + 5.0;}
	}
	if(dlambda > 1.0){
		   if(dlambda == 5.0){dlambda = dlambda - 4.0;}
		   else{dlambda = dlambda - 5.0;}
	}
	#print "... dlambda = " , dlambda;

#	print "Determining dphi ...";
#	print "phi_span = ", phi_span;

	dphi=1.0;
	while(N*dphi<phi_span){
#		print dphi;
		if(dphi == 1.0){dphi = dphi + 4.0;}
		else{dphi = dphi + 5.0;}
	}
	if(dphi > 1.0){
		   if(dphi == 5.0){dphi = dphi - 4.0;}
		   else{dphi = dphi - 5.0;}
	}
#	print "... dphi = " , dphi;



#	print "Setting xtics at dlambda intervals:";

	set format x "";     
	set xtics ();

	lambda= (int(lambda_min/dlambda))*dlambda;
	x = xe(lambda);
	while(x < GPVAL_DATA_X_MAX){
		set xtics add (label_deg(lambda_inv(x)) x);
		set arrow from first x, graph 0 to first x, graph 1 nohead  linecolor "gray"

		
#		print lambda_inv(x);
		x = x + dlambda*k;
		#lambda = lambda + dlambda;

	}




 
	#if(dlambda == 1.0){
	#	print "Setting mxtics";
	#	set mxtics 60;
	#	show mxtics;
	#}


#	print "Setting ytics at dphi intervals:";
	
	set format y "";     
	set ytics ();
	phi = (int(phi_min/dphi))*dphi;
	while(phi<phi_max){
		set ytics add (label_deg(phi) ye(phi));
		set arrow from graph 0,first ye(phi) to graph 1, first ye(phi) nohead  linecolor "gray"
#		print phi;
		phi = phi + dphi;


	}



	refresh;
	x_max_old = GPVAL_DATA_X_MAX;

	}


    	pause 1e-1      # waiting time in seconds
}
