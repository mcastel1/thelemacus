reset 

#notes:
#to kill all gnuplot processes type: pkill -9 gnuplot
#- using webgeocals improves agreement between circle of equal altitude and true position by ~ 100 m
#do not use stellarium to compute hour angle and declination: they are calculated with the reference frame sitting on the surface of the earth at the observer's location! 
#here 0 <= lambda < 360.0, and it grows in the W direction
#notes
K = 360.0/(2.0*pi);
k = 1.0/K;
N = 6.0;
#circles of equal altitude are plotted with S points
S = 1e4;
M = 135;
epsilon=1e-10
myint(x) = x>0.0 ? int(x) : int(x)-1.0
clint(x) = abs(x-myint(x))<abs(x-(myint(x)+1.)) ? myint(x) : myint(x)+1.
#extracts degrees and minutes from floating-point angle in degree format
degrees(x) = floor(x);
minutes(x) = (x > 0.0 ? (x - floor(x))*60.0 : (1.0 - (x - floor(x)))*60.0)
is_int(x) = ((( abs(x - floor(x)) < epsilon ) || ( abs(x - ceil(x)) < epsilon)) ? 1 : 0)
key_y = 0.98;
key_x = 0.07;
key_spacing = 0.04;


#Mercator for the sphere
#MINUS SIGN ADDED BY HAND TO FLIP THE MAP
xe(lambda) =  (-1.0) * ( ((0.0 <= lambda) & (lambda < 180.0)) ? lambda: lambda - 360.0 )*k
ye(phi) = (log(1./cos(phi*k) + tan(phi*k)))
lambda_inv(xe) = ( ((xe <= 0.0) & (xe > -pi)) ? -xe*K: -xe*K + 360.0 )
#given xe, this returns the corresponding lambda in non-standard format, i.e., lying in the interval [-pi, pi)
lambda_inv_pm(xe) = -xe*K 
phi_inv(ye) = K*atan(sinh(ye))	

myf(x,y)=sprintf("%g\260 %g' %s , %g\260 %g' %s", myint(abs(phi_inv(y))), (abs(phi_inv(y)) - myint(abs(phi_inv(y))))*60.0, (phi_inv(y) > 0.0 ? 'N': 'S'), myint(abs(lambda_inv_pm(x))), (abs(lambda_inv_pm(x)) - myint(abs(lambda_inv_pm(x))))*60.0, ((lambda_inv_pm(x) > 0.0) ? 'W': 'E'))
set mouse mouseformat function myf(x, y)
set mouse mouseformat 8


#clear
set parametric
set multiplot

set size ratio -1
set key top left
#size of minor x and y tics with respect to screen size (1 = tic as long as screen size)
mtics_size = 0.01
set xtics rotate by 45 offset 0,graph -0.09

set format x "";     
set xtics ();

set format y "";     
set ytics ();

set ticscale 3,1
set samples S
#increments in degrees
increment_phi = 20.0;
increment_lambda = 60.0;
list(start,end,increment)=system(sprintf("seq %g %g %g", start, increment, end))


#set tics scale 0


Phi(t, d, GHA, cH) =pi/2.-acos(cos(cH) * sin(d)-cos(d) * cos(t) * sin(cH))
Lambda(t, d, GHA, cH) = ( lambda = -(atan((-sin(GHA) * (cos(d)* cos(cH)+cos(t) * sin(d) * sin(cH))+cos(GHA) * sin(cH) * sin(t))/(cos(d) * cos(GHA) * cos(cH)+sin(cH)*  (cos(GHA) * cos(t) * sin(d)+sin(GHA)* sin(t)))) + (cos(d)* cos(GHA)* cos(cH) +  sin(cH) * (cos(GHA)* cos(t) * sin(d) + sin(GHA)  *sin(t)) >0.0 ? 0.0 : pi)) , lambda - 2.0*pi*floor(lambda/(2.0*pi)))





#angles are in degrees
#lambda_min is the angle which corresponds to the leftmost x coordinate x_min in the Mercator plot, and simiarly for lambda_max
#min_longitude
#max_longitude
#min_latitude
#max_latitude

set xrange [xe(lambda_min):xe(lambda_max)]
set yrange [ye(phi_min):ye(phi_max)]

dx = ye((phi_min+phi_max)/2.0+1./60.) -  ye((phi_min+phi_max)/2.0)

set style arrow 1 nohead ls 1 lw 1 linecolor rgb 'black'
set style arrow 2 nohead ls 1 lw 1 linecolor rgb 'gray'


label_rose(n) = sprintf("\\scalebox{0.3}{$\\color{mygray}{%d}$}",n)
label_deg_latitude(x) = ( x == 0.0 ) ? sprintf("0\260") : ( x > 0.0 ? sprintf("%.f\260 N", x - myint(x/360.0)*360.0) : sprintf("%.f\260 S", ((-x) - myint((-x)/360.0)*360.0)) )
label_deg_longitude(x) = ( x == 0.0 ) ? sprintf("0\260") : ( x < 180.0 ? sprintf("%.f\260 W", x - myint(x/360.0)*360.0) : sprintf("%.f\260 E", 360.0 - (x - myint(x/360.0)*360.0)) )
#this prints the arcminutes only of angle x
label_min(x) = sprintf("%.f'", minutes(x) ) 
#if the arcminutes are zero, I print out only the degrees for clarity
label_deg_min(x) =  ( minutes(x) == 0.0 ? sprintf("%.f\260", degrees(x)) : sprintf("%.f\260 %.f'", degrees(x), minutes(x)) ) 


#GPS position
#lambda0 = 360.0 -(2.0 + 24./60. + 26.07/(60.**2.))
#phi0 = 48.0 + 51./60. + 19.63/(60.**2.)
#set object circle at  xe(lambda0),ye(phi0) radius char 1  fillcolor rgb 'red' fillstyle solid noborder

#coastlines
#plot   '/Users/mcastellana/Documents/navigational_astronomy_large_files/coastlines_2/map_conv.csv' u (xe(-$1+360.0)):(ye($2)) every M w d linecolor rgb "gray" noti
p 0,0 w l noti

#unset parametric
unset multiplot

x_max_old = 0.0;

while(1){

	if(GPVAL_X_MAX!=x_max_old){


	unset arrow;
	set bmargin 6;
	

	#print "Recalculating tics ... ";

	lambda_min = lambda_inv(GPVAL_X_MIN);
	lambda_max = lambda_inv(GPVAL_X_MAX);
	
	phi_min = phi_inv(GPVAL_Y_MIN);
	phi_max = phi_inv(GPVAL_Y_MAX);

	set xrange [xe(lambda_min):xe(lambda_max)]
	set yrange [ye(phi_min):ye(phi_max)]

	phi_span = phi_max - phi_min;
	lambda_span = -(-(GPVAL_X_MAX - GPVAL_X_MIN)*K);
	
	#print "lambda in [" , lambda_min , " , " , lambda_max , "]";
	#print "phi in [" , phi_min , " , " , phi_max , "]";

	#print "x in [" , GPVAL_X_MIN , " , " , GPVAL_X_MAX , "]";
	#print "y in [" , GPVAL_Y_MIN , " , " , GPVAL_Y_MAX , "]";


	#print "Determining dlambda ...";

	#gamma_lambda is the compression factor which allows from switching from increments in degrees to increments in arcminutes
	if(lambda_span > 1.0){gamma_lambda = 1.0;}
	else{gamma_lambda = 60.0;}

	dlambda=1.0/gamma_lambda;
	while(N*dlambda<lambda_span){
	#print dlambda;
	if(dlambda == 1.0/gamma_lambda){dlambda = dlambda + 4.0/gamma_lambda;}
	else{dlambda = dlambda + 5.0/gamma_lambda;}
	}
	if(dlambda > 1.0/gamma_lambda){
		   if(dlambda == 5.0/gamma_lambda){dlambda = dlambda - 4.0/gamma_lambda;}
		   else{dlambda = dlambda - 5.0/gamma_lambda;}
	}
	#print "... dlambda = " , dlambda;


	#print "Determining dphi ...";
	#print "phi_span = ", phi_span;

	#gamma_phi is the compression factor which allows from switching from increments in degrees to increments in arcminutes
	if(phi_span > 1.0){gamma_phi = 1.0;}
	else{gamma_phi = 60.0;}
	
	dphi=1.0/gamma_phi;
	while(N*dphi<phi_span){
		#print dphi;
		if(dphi == 1.0/gamma_phi){dphi = dphi + 4.0/gamma_phi;}
		else{dphi = dphi + 5.0/gamma_phi;}
	}
	if(dphi > 1.0/gamma_phi){
		   if(dphi == 5.0/gamma_phi){dphi = dphi - 4.0/gamma_phi;}
		   else{dphi = dphi - 5.0/gamma_phi;}
	}
	#print "... dphi = " , dphi;



	#print "Setting xtics at dlambda intervals:";

	set format x "";     
	set xtics ();

	lambda= (int(lambda_min/dlambda))*dlambda;
	x = xe(lambda);

	#plot the first few custom-made myxics close to the left edge of the x axis. Here I consider 		x = x + dlambda*k (the first value of x which is an 'integer multiple of dlambda' and which is contained in the x axis), and then decrease it by one tenth of arcminute in the while loop
	if(gamma_lambda == 60.0){
					i=0.0;
					while(x + (dlambda + (i/10.0)*1.0/60.0)*k >= GPVAL_X_MIN){
				             #set custom-made minor xtics every tenths (i/10.0) of arcminutes (1.0/60.0) 
					     set arrow from first x + (dlambda + (i/10.0)*1.0/60.0)*k, graph 0 to first x + (dlambda + (i/10.0)*1.0/60.0)*k, graph mtics_size nohead  linecolor "blue";
					     i=i-1.0;
					}
			 	   
	}


	while(x <= GPVAL_X_MAX){
 
		lambda = lambda_inv(x);

		if(x >= GPVAL_X_MIN){

		          if(is_int(lambda) == 1){
		       		      set xtics add (label_deg_longitude(lambda) x);
		          }else{
		       		      set xtics add (label_min(lambda) x);
		          }

			  if(gamma_lambda == 60.0){
			  	   i=0.0;
				   #plot the custom-made xtics from x to the next x (x + dlambda*k)
				   while(x + (i/10.0)*1.0/60.0*k <  x + dlambda*k){
					if(x + (i/10.0)*1.0/60.0*k <= GPVAL_X_MAX){
					     #set custom-made minor xtics every tenths (i/10.0) of arcminutes (1.0/60.0) 
					     set arrow from first x + (i/10.0)*1.0/60.0*k, graph 0 to first x + (i/10.0)*1.0/60.0*k, graph mtics_size nohead  linecolor "blue";
					}
					i=i+1.0;
			 	   }
		          }


			  set arrow from first x, graph 0 to first x, graph 1 nohead  linecolor "gray";


		}

		
		#print lambda_inv(x);
		x = x + dlambda*k;
		#lambda = lambda + dlambda;

	}




 
	#if(dlambda == 1.0){
	#	print "Setting mxtics";
	#	set mxtics 60;
	#	show mxtics;
	#}


	#print "Setting ytics at dphi intervals:";
	
	set format y "";     
	set ytics ();
	phi = (int(phi_min/dphi))*dphi;

	#plot the first few custom-made mytics close to the lower edge of the y axis. Here I consider phi + dphi (the first value of phi which is an 'integer multiple of dphi' and which is contained in the y axis), and then decrease it by one tenth of arcminute in the while loop
	if(gamma_phi == 60.0){
					i=0.0;
					while(ye(phi + dphi + (i/10.0)*1.0/60.0) >= GPVAL_Y_MIN){
						  #set custom-made minor ytics every tenths (i/10.0) of arcminutes (1.0/60.0) 
		       	 		       	  set arrow from graph 0,first ye(phi + dphi + (i/10.0)*1.0/60.0) to graph mtics_size, first ye(phi + dphi + (i/10.0)*1.0/60.0) nohead  linecolor "blue";
					i=i-1.0;
					}
			 	   
	}

	while(phi<=phi_max){
		if(phi >= phi_min){
		       if(is_int(phi) == 1){
		       		      set ytics add (label_deg_latitude(phi) ye(phi));
		       }else{
		       		      set ytics add (label_min(phi) ye(phi));
		       }

		       if(gamma_phi == 60.0){
			  	   i=0.0;
				   #plot the custom-made ytics from phi to the next phi (phi + dphi)
			 	   while(phi + (i/10.0)*1.0/60.0 < phi + dphi){
					if(phi + (i/10.0)*1.0/60.0 <= phi_max){
						#set custom-made minor ytics every tenths (i/10.0) of arcminutes (1.0/60.0) 
		       	 		       set arrow from graph 0,first ye(phi + (i/10.0)*1.0/60.0) to graph mtics_size, first ye(phi + (i/10.0)*1.0/60.0) nohead  linecolor "blue";
					}
					i=i+1.0;
			 	   }
		       }

		       set arrow from graph 0,first ye(phi) to graph 1, first ye(phi) nohead  linecolor "gray";
		}
		#print phi;
		phi = phi + dphi;


	}


	clear;

	set multiplot	
	#coastlines
	plot   '/Users/mcastellana/Documents/navigational_astronomy_large_files/coastlines_2/map_conv.csv' u (xe(-$1+360.0)):(ye($2)) every M w d linecolor rgb "gray" noti

	
 set key at graph key_x, graph key_y - 1*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 6.0016343222782575494989032449666, 0.11276663835826482296109674052786, 1.1418435881749906535276295471704)), ye(K*Phi(t, 6.0016343222782575494989032449666, 0.11276663835826482296109674052786, 1.1418435881749906535276295471704)) smo csp dashtype 1 lt 1 ti "moon 2021-06-21 21:39:32 TAI, Sight was taken at BGC"

 set key at graph key_x, graph key_y - 2*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 6.0009779746737130778910795925185, 0.15713928023821471802179416954459, 1.1482512962972457604138298847829)), ye(K*Phi(t, 6.0009779746737130778910795925185, 0.15713928023821471802179416954459, 1.1482512962972457604138298847829)) smo csp dashtype 2 lt 2 ti "moon 2021-06-21 21:50:05.99 TAI, Sight was taken at BGC"

 set key at graph key_x, graph key_y - 3*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 0.33300635349119828143571453438199, 1.0139375075339236431659628578927, 0.98485670597599828113288822351024)), ye(K*Phi(t, 0.33300635349119828143571453438199, 1.0139375075339236431659628578927, 0.98485670597599828113288822351024)) smo csp dashtype 3 lt 3 ti "arcturus 2021-07-06 23:08:53.82 TAI, Sight was taken at BGC"

 set key at graph key_x, graph key_y - 4*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 0.39159131251279977181667391050723, 4.9428640643130146159478499612305, 1.1020586613425791266962505687843)), ye(K*Phi(t, 0.39159131251279977181667391050723, 4.9428640643130146159478499612305, 1.1020586613425791266962505687843)) smo csp dashtype 4 lt 4 ti "sun 2021-07-08 06:58:23.83 TAI, Sight was taken at MP"

 set key at graph key_x, graph key_y - 5*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 0.35951509093697581187498713006789, 4.9806932986108636285393913567532, 1.1007526311195947599230748892296)), ye(K*Phi(t, 0.35951509093697581187498713006789, 4.9806932986108636285393913567532, 1.1007526311195947599230748892296)) smo csp dashtype 5 lt 5 ti "sun 2021-07-20 07:08:21.37 TAI, Sight was taken at MP"

 set key at graph key_x, graph key_y - 6*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 0.35950314151211570923294402746251, 5.0033600725495439576206990750507, 1.0855637357623084682245462317951)), ye(K*Phi(t, 0.35950314151211570923294402746251, 5.0033600725495439576206990750507, 1.0855637357623084682245462317951)) smo csp dashtype 6 lt 6 ti "sun 2021-07-20 07:13:33.07 TAI, Sight was taken at MP"

 set key at graph key_x, graph key_y - 7*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 5.9625679024251265758493900648318, 5.8689068280786935716264451912139, 1.219306826232512630525661734282)), ye(K*Phi(t, 5.9625679024251265758493900648318, 5.8689068280786935716264451912139, 1.219306826232512630525661734282)) smo csp dashtype 7 lt 7 ti "saturn 2021-07-29 22:46:41.54 TAI, Sight was taken at BGC"

 set key at graph key_x, graph key_y - 8*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 6.063554151690781601757862517843, 5.5859356926821757127754608518444, 1.2188204414339045555948359833565)), ye(K*Phi(t, 6.063554151690781601757862517843, 5.5859356926821757127754608518444, 1.2188204414339045555948359833565)) smo csp dashtype 8 lt 8 ti "jupiter 2021-07-29 22:58:47.73 TAI, Sight taken at BGC"

 set key at graph key_x, graph key_y - 9*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 6.0635515019633130506804263859522, 5.6082477929716620934641468920745, 1.2095934061088866595667923320434)), ye(K*Phi(t, 6.0635515019633130506804263859522, 5.6082477929716620934641468920745, 1.2095934061088866595667923320434)) smo csp dashtype 9 lt 9 ti "jupiter 2021-07-29 23:03:53.62 TAI, Sight was taken at BGC"

 set key at graph key_x, graph key_y - 10*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 6.0359041205882091318812854296993, 6.1307955025492351097682330873795, 1.104199390670579816742247203365)), ye(K*Phi(t, 6.0359041205882091318812854296993, 6.1307955025492351097682330873795, 1.104199390670579816742247203365)) smo csp dashtype 10 lt 10 ti "jupiter 2021-09-02 22:28:52.94 TAI, Sight was taken at MP"

 set key at graph key_x, graph key_y - 11*key_spacing
plot [0.:2.*pi] xe(K*Lambda(t, 6.0358988320332684907043585553765, 6.1760020468963015005670058599208, 1.1013011667928371828395484044449)), ye(K*Phi(t, 6.0358988320332684907043585553765, 6.1760020468963015005670058599208, 1.1013011667928371828395484044449)) smo csp dashtype 11 lt 11 ti "jupiter 2021-09-02 22:39:12.67 TAI, Sight was taken at MP"

 set key at graph key_x, graph key_y - 12*key_spacing
plot [0.:1.4002153842380051784743955067825 - epsilon] xe(K*Lambda(t, 0.80326138418276193942091367716785, 4.3174550985202042596711180522107, 1.1768564601383246781551861204207)), ye(K*Phi(t, 0.80326138418276193942091367716785, 4.3174550985202042596711180522107, 1.1768564601383246781551861204207)) smo csp dashtype 12 lt 12 ti "capella 2021-09-03 22:55:03.877 TAI, Sight was taken at MP"
plot [1.4002153842380051784743955067825 + epsilon:2.*pi] xe(K*Lambda(t, 0.80326138418276193942091367716785, 4.3174550985202042596711180522107, 1.1768564601383246781551861204207)), ye(K*Phi(t, 0.80326138418276193942091367716785, 4.3174550985202042596711180522107, 1.1768564601383246781551861204207)) smo csp dashtype 12 lt 12 noti 

	
 set key at graph key_x, graph key_y - 13*key_spacing
plot "+" u (xe(K*(6.2410583415053162426033850351814))):(ye(K*(0.85264552071863697335629694862291))) w p lw 2 lt 1 ti "Centre Sportif Maryse Hilsz (MH)"

 set key at graph key_x, graph key_y - 14*key_spacing
plot "+" u (xe(K*(6.241171014205057154811129294103))):(ye(K*(0.85268850862179457195111353939865))) w p lw 2 lt 2 ti "Baby Gym Campo (BGC)"

 set key at graph key_x, graph key_y - 15*key_spacing
plot "+" u (xe(K*(6.2411274295520877686271887796465))):(ye(K*(0.8526832726340385359975471146754))) w p lw 2 lt 3 ti "My Place (MP)"

 set key at graph key_x, graph key_y - 16*key_spacing
plot "+" u (xe(K*(0.018035068937274741779352993376051))):(ye(K*(0.57683131778412588541726790936082))) w p lw 2 lt 4 ti "2021-11-17 17:20:36"


	x_max_old = GPVAL_X_MAX;

	system("rm boundary.txt  > /dev/null 2>&1");
        set print "boundary.txt";
	print "GPVAL_X_MIN = ", GPVAL_X_MIN, "\n", "GPVAL_X_MAX = ", GPVAL_X_MAX, "\n", "GPVAL_Y_MIN = ", GPVAL_Y_MIN, "\n", "GPVAL_Y_MAX = ", GPVAL_Y_MAX;

	}


    	pause 1e-3      # waiting time in seconds
}
